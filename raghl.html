<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Summary</title>
    <style>
     body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.8;
    background-color: #e3f2fd; /* Light blue background */
    color: #212529;
    margin: 0;
    padding: 20px;
}

h1, h2, h3 {
    background-color: #007bff; /* Blue background */
    color: #ffffff; /* White text color */
    margin: 20px 0; /* Margin above and below */
    padding: 10px; /* Padding inside the heading */
    border-radius: 5px; /* Rounded corners */
}

h1 {
    text-align: center;
    text-transform: uppercase;
    margin-bottom: 20px;
}

h2 {
    margin-top: 30px;
    border-bottom: 2px solid #091624;
    padding: 10px;
    background-color: #007bff;
    border-radius: 4px;
    color: #ffffff;
}

h3 {
    margin-top: 20px;
    font-style: italic;
}

.navbar {
    position: sticky;
    top: 0;
    background-color: #0056b3; /* Changed pink to blue */
    width: 100%;
    z-index: 1000;
    padding: 0.5rem 1rem;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    display: flex;
    border-radius: 10px;
    justify-content: center;
    justify-content: space-between;
}

.nav-list {
    list-style: none;
    display: flex;
    justify-content: space-around;
    align-content: center;
    margin: 0;
    padding: 0;
}

.nav-list li {
    margin: 0;
    color: #ffffff; /* White text in navbar */
}

.nav-list a {
    text-decoration: none;
    color: #ffffff; /* White text color */
    padding: 1rem 1rem;
    transition: background-color 0.3s ease;
}

.nav-list a:hover {
    transform: scale(1.02);
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    transition: transform 0.2s, box-shadow 0.2s;
    border-radius: 4px;
}
    </style>
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a style="color:rgb(255, 255, 255)"  href="/swargansh.topic.github.io/home.html">Home</a></li>
            <li><a style="color:rgb(255, 255, 255)"  href="/swargansh.topic.github.io/index.html">PROJECT OVERVIEW</a></li>
            <li><a  style="color:rgb(253, 251, 251)" href="/swargansh.topic.github.io/teamlearning.html">Learning Reflections</a></li>
        </ul>
    </nav>
  <section>
    <div class="container">
        <h1>Data Structures and Algorithms Summary</h1>

        <h2>1. Problems in Nature</h2>
        <ul>
            <li><strong>Iteration:</strong> :  The daily foraging behavior of birds where they iterate through various feeding spots until they find food..</li>
            <li><strong>Recursion:</strong> :  The process of tree branching, where each new branch further divides into smaller branches.</li>
            <li><strong>Backtracking:</strong> : A foraging animal encountering dead-ends and needing to backtrack to find a new path.</li>
        </ul>

        <h2>2. Space and Time Efficiency</h2>
        <ul>
            <li><strong>Space Efficiency:</strong> : Extra space required by an algorithm.</li>
            <li><strong>Time Efficiency:</strong>  : Extra time required by an algorithm.</li>
        </ul>
        <h3>Order of Growth:</h3>
        <ul>
            <li><code>O(1)</code> - Constant</li>
            <li><code>O(n)</code> - Linear</li>
            <li><code>O(log n)</code> - Logarithmic</li>
            <li><code>O(n^2)</code> - Quadratic</li>
            <li><code>O(n log n)</code> - Linearithmic</li>
            <li><code>O(n^3)</code> - Cubic</li>
            <li><code>O(n^k)</code> - Polynomial</li>
            <li><code>O(2^n)</code> - Exponential</li>
            <li><code>O(n!)</code> - Factorial</li>
        </ul>
        <div class="note">
            <p><strong>Best Case:</strong> Performs Minimum number of steps.</p>
            <p><strong>Average Case:</strong> Expected over all possible inputs.</p>
            <p><strong>Worst Case:</strong> Performs Maximum number of steps.</p>
        </div>

        <h2>3. Design Principles (from Chapter 2)</h2>
        <p>Sorting algorithms aim to reduce the number of comparisons, similar to graph algorithms where we aim to minimize operations like pathfinding or traversing.</p>

        <h2>4. Tree Data Structures</h2>
        <ul>
            <li><strong>Tree:</strong> Flexible but search or traversal may take O(n) due to lack of ordering or balancing.</li>
            <li><strong>BST:</strong> Reduces the complexity of search operations to O(log n) on average by maintaining sorted order.</li>
            <li><strong>AVL Tree:</strong> Balances the tree after every insertion or deletion, ensuring O(log n) operations.</li>
            <li><strong>2-3 Tree:</strong> Always balanced, handling multiple keys in each node.</li>
            <li><strong>Red-Black Tree</strong>  Less strict balancing, reducing the overhead of rotations during updates.</li>
            <li><strong>Heap:</strong> Guarantees O(1) for finding max/min and O(log n) for insertions and deletions.</li>
            <li><strong>Trie:</strong> Exploits shared prefixes, ideal for large datasets with overlapping entries.</li>
        </ul>

        <h2>5. Array Query Algorithms</h2>
        <li><strong>Array query algorithms:</strong> Fenwick Tree, Segment Tree, Lookup Table.</li>
        <li>These algorithms are essential for efficiently processing, retrieving, and analyzing data stored in arrays, especially with large datasets or frequently repeated queries.</li>
        <li><strong>Fenwick Tree:</strong>
            <ul>
                <li><strong>Principle:</strong> Supports efficient range queries and point updates.</li>
                <li><strong>Application:</strong> Cumulative frequency counts in online queries.</li>
            </ul>
        </li>
        <li><strong>Segment Tree:</strong>
            <ul>
                <li><strong>Principle:</strong> Divides array into segments for range queries and updates.</li>
                <li><strong>Application:</strong> Dynamic histograms.</li>
            </ul>
        </li>
        <li><strong>Lookup Table:</strong>
            <ul>
                <li><strong>Principle:</strong> Precomputes results for all possible inputs.</li>
                <li><strong>Application:</strong> Collision detection, AI decision trees.</li>
            </ul>
        </li>

        <h2>6. Difference Between Tree and Graph Traversals</h2>
        <table>
            <tr>
                <th>Feature</th>
                <th>Tree</th>
                <th>Graph</th>
            </tr>
            <tr>
                <td>Definition</td>
                <td>A hierarchical data structure with nodes connected by edges.</td>
                <td>A general data structure with nodes (vertices) connected by edges (can be directed/undirected).</td>
            </tr>
            <tr>
                <td>Structure</td>
                <td>Connected and acyclic.</td>
                <td>May be connected or disconnected, cyclic or acyclic.</td>
            </tr>
            <tr>
                <td>Root</td>
                <td>Has a single root node.</td>
                <td>No concept of a root (unless it's a tree-based graph).</td>
            </tr>
            <tr>
                <td>Parent-Child Relationship</td>
                <td>Nodes follow a strict parent-child hierarchy.</td>
                <td>No strict hierarchy; any node can connect to any other node.</td>
            </tr>
            <tr>
                <td>Edges</td>
                <td>Exactly n−1 edges for n nodes.</td>
                <td>Can have any number of edges (up to n(n−1)/2 for undirected graphs).</td>
            </tr>
            <tr>
                <td>Traversal</td>
                <td>DFS and BFS, plus tree-specific traversals (inorder, preorder, postorder).</td>
                <td>Typically DFS and BFS, without hierarchy-based traversal.</td>
            </tr>
            <tr>
                <td>Cyclic Nature</td>
                <td>Always acyclic.</td>
                <td>Can contain cycles (e.g., directed graphs with loops).</td>
            </tr>
        </table>

        <h2>7. Sorting Algorithms</h2>
        <ul>
            <li><strong>Bubble Sort:</strong> Repeatedly swaps adjacent elements if they are in the wrong order. </li>
            <li><strong>Selection Sort:</strong> Selects the smallest (or largest) element and places it at the correct position.</li>
            <li><strong>Insertion Sort:</strong> Builds the sorted array one element at a time by placing it in its correct position.</li>
            <li><strong>Quick Sort:</strong> Partitions the array around a pivot and sorts the partitions recursively.</li>
            <li><strong>Merge Sort:</strong> Divides the array into halves, sorts them, and then merges them back together.</li>
            <li><strong>Heap Sort:</strong> Builds a heap from the array and repeatedly extracts the maximum element.</li>
        </ul>

        <h2>8. Shortest Path Algorithms</h2>
        <ul>
            <li><strong>Dijkstra’s Algorithm:</strong> Finds the shortest path from a single source to all other nodes using a priority queue.</li>
            <li><strong>Bellman-Ford Algorithm:</strong> Handles graphs with negative edge weights by relaxing edges up to (V-1) times.</li>
            <li><strong>Warshall’s Algorithm:</strong> Finds shortest paths between all pairs of nodes using dynamic programming.</li>
            <li><strong>Kruskal’s Algorithm:</strong> Greedy algorithm used to find the Minimum Spanning Tree (MST) of a graph.</li>
            <li><strong>Floyd’s Algorithm:</strong> Dynamic programming algorithm used to find the shortest paths between all pairs of vertices in a weighted graph.</li>
            <li><strong>Prim’s Algorithm:</strong> Greedy algorithm used to find the Minimum Spanning Tree (MST) for a weighted graph</li>
            <li><strong>Depth First Search Algorithm:</strong> Graph traversal algorithm that explores as far as possible along each branch before backtracking.</li>
        </ul>

        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Brute Force:</strong> Explore all possible solutions to select the best one.</li>
            <li><strong>Divide and Conquer:</strong> This involves dividing the Problem into smaller subproblems,solving them recursively and merge the solutions.    </li>
            <li><strong>Backtracking:</strong> Its a trial and error approach where solutions are incrementally built and abondoned if they are not feasible.</li>
            <li><strong>Recursion:</strong> Solve a problem by solving smaller instances of the same problem</li>
        </ul>
    </div>
  </section>
   <button onclick="window.history.back();" style="background-color: #1b2391; color: white; border: none; padding: 10px 20px; font-size: 1rem; cursor: pointer; border-radius: 5px; margin-bottom: 20px;">Back</button>
</body>
</html>
